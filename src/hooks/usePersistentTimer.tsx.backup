import { useState, useEffect, useRef, useCallback } from 'react';
import { supabase } from '../lib/db';
import { useAuth } from '../context/AuthContext';

interface CheckInSession {
  id: string;
  type: 'warehouse' | 'event';
  warehouseId?: string;
  eventId?: string;
  checkInTime: string;
  scheduledEndTime: string;
  shiftName?: string;
  shiftStartTime?: string;
  shiftEndTime?: string;
  hasLunchBreak?: boolean;
  hasCompanyMeal: boolean;
  hasMealVoucher: boolean;
  breakTime?: number;
  isActive: boolean;
  elapsedTime?: string;
}

export const usePersistentTimer = () => {
  const { user } = useAuth();
  const [currentSession, setCurrentSession] = useState<CheckInSession | null>(null);
  const [activeSessions, setActiveSessions] = useState<CheckInSession[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [elapsedTime, setElapsedTime] = useState<string>('00:00:00');
  const [elapsedTimes, setElapsedTimes] = useState<Record<string, string>>({});
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const multiTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Avvia il timer quando c'√® una sessione attiva
  useEffect(() => {
    if (currentSession && currentSession.isActive) {
      startTimer(currentSession.checkInTime);
    } else {
      stopTimer();
    }

    return () => {
      stopTimer();
    };
  }, [currentSession?.id, currentSession?.isActive]);

  // Avvia timer multipli per tutte le sessioni attive
  useEffect(() => {
    if (activeSessions.length > 0) {
      startMultipleTimers(activeSessions);
    } else {
      stopMultipleTimers();
    }

    return () => {
      stopMultipleTimers();
    };
  }, [activeSessions.length]);

  const startTimer = (checkInTime: string) => {
    // Pulisci timer esistente
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    // Calcola ora di inizio
    const today = new Date();
    const [hours, minutes] = checkInTime.split(':').map(Number);
    const startTime = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hours, minutes, 0);

    const updateTimer = () => {
      const now = new Date();
      const diffMs = now.getTime() - startTime.getTime();
      
      if (diffMs < 0) {
        setElapsedTime('00:00:00');
        return;
      }

      const totalSeconds = Math.floor(diffMs / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      
      const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      setElapsedTime(formattedTime);
    };

    // Aggiorna immediatamente
    updateTimer();
    
    // Poi ogni secondo
    timerRef.current = setInterval(updateTimer, 1000);
  };

  const stopTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
    setElapsedTime('00:00:00');
  };

  const startMultipleTimers = (sessions: CheckInSession[]) => {
    if (multiTimerRef.current) {
      clearInterval(multiTimerRef.current);
    }

    const updateAllTimers = () => {
      const now = new Date();
      const today = new Date();
      const newElapsedTimes: Record<string, string> = {};

      sessions.forEach(session => {
        const [hours, minutes] = session.checkInTime.split(':').map(Number);
        const startTime = new Date(today.getFullYear(), today.getMonth(), today.getDate(), hours, minutes, 0);
        const diffMs = now.getTime() - startTime.getTime();

        if (diffMs < 0) {
          newElapsedTimes[session.id] = '00:00:00';
          return;
        }

        const totalSeconds = Math.floor(diffMs / 1000);
        const hrs = Math.floor(totalSeconds / 3600);
        const mins = Math.floor((totalSeconds % 3600) / 60);
        const secs = totalSeconds % 60;

        newElapsedTimes[session.id] = `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      });

      setElapsedTimes(newElapsedTimes);
    };

    updateAllTimers();
    multiTimerRef.current = setInterval(updateAllTimers, 1000);
  };

  const stopMultipleTimers = () => {
    if (multiTimerRef.current) {
      clearInterval(multiTimerRef.current);
      multiTimerRef.current = null;
    }
    setElapsedTimes({});
  };

  // Carica sessione attiva dal database all'avvio
  useEffect(() => {
    if (user?.id) {
      loadActiveSession();
    }
  }, [user?.id]);

  const loadActiveSession = async () => {
    try {
      setIsLoading(true);

      if (!supabase) {
        return;
      }

      const today = new Date().toISOString().split('T')[0];
      const allSessions: CheckInSession[] = [];

      // Cerca check-in magazzino attivo (checked_in ma non checked_out)
      const { data: warehouseCheckIn, error: warehouseError } = await supabase
        .from('warehouse_checkins')
        .select('*')
        .eq('crew_id', user?.id)
        .eq('date', today)
        .in('status', ['active', 'checked_in'])
        .is('check_out_time', null)
        .maybeSingle();

      if (!warehouseError && warehouseCheckIn) {
        const session: CheckInSession = {
          id: warehouseCheckIn.id,
          type: 'warehouse',
          warehouseId: warehouseCheckIn.warehouse_id,
          checkInTime: warehouseCheckIn.check_in_time,
          scheduledEndTime: '17:00',
          shiftName: 'Turno Magazzino',
          hasCompanyMeal: warehouseCheckIn.company_meal || false,
          hasMealVoucher: warehouseCheckIn.meal_voucher || false,
          breakTime: warehouseCheckIn.break_minutes || 0,
          isActive: true
        };

        allSessions.push(session);
        setCurrentSession(session);
      }

      // Cerca timesheet evento attivo
      const { data: eventTimesheet, error: eventError } = await supabase
        .from('timesheet_entries')
        .select(`
          *,
          crew_events!event_id(title, end_date, location)
        `)
        .eq('crew_id', user?.id)
        .eq('date', today)
        .eq('status', 'draft')
        .is('end_time', null)
        .maybeSingle();

      if (!eventError && eventTimesheet) {
        const eventData = eventTimesheet.crew_events as any;
        const session: CheckInSession = {
          id: eventTimesheet.id,
          type: 'event',
          eventId: eventTimesheet.event_id,
          checkInTime: eventTimesheet.start_time,
          scheduledEndTime: '17:00',
          shiftName: eventData?.title || 'Evento',
          hasCompanyMeal: eventTimesheet.company_meal || false,
          hasMealVoucher: eventTimesheet.meal_voucher || false,
          isActive: true
        };

        allSessions.push(session);

        if (!warehouseCheckIn) {
          setCurrentSession(session);
        }
      }

      setActiveSessions(allSessions);

    } catch (error) {
      console.error('Errore caricamento sessioni:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const startSession = useCallback((sessionData: Omit<CheckInSession, 'isActive'>) => {
    const session = { ...sessionData, isActive: true };
    setCurrentSession(session);
    
    // Il timer si avvier√† automaticamente tramite useEffect
  }, []);

  const endSession = useCallback((sessionId?: string) => {
    if (sessionId) {
      // Rimuovi la sessione specifica dall'array
      setActiveSessions(prev => prev.filter(s => s.id !== sessionId));

      // Se la sessione terminata √® la currentSession, azzerala
      if (currentSession?.id === sessionId) {
        stopTimer();
        setCurrentSession(null);
      }
    } else {
      // Comportamento legacy: termina currentSession
      stopTimer();
      setCurrentSession(null);
    }
  }, [currentSession]);

  const manualCheckOut = async (checkoutLocation?: any) => {
    if (!currentSession) {
      console.error('‚ùå Nessuna sessione attiva per check-out');
      return false;
    }

    try {
      if (!user?.id) {
        console.error('‚ùå User ID non valido per check-out');
        return false;
      }

      const now = new Date();
      const checkOutTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

      console.log(`üîÑ Tentativo check-out manuale alle ${checkOutTime} per sessione ${currentSession.id}`);
      console.log(`üìã Tipo sessione: ${currentSession.type}`);
      console.log('üìç Checkout location:', checkoutLocation);

      if (currentSession.type === 'warehouse') {
        console.log(`üíæ Aggiornamento warehouse_checkins id=${currentSession.id}`);

        const updateData: any = {
          check_out_time: checkOutTime,
          status: 'completed'
        };

        // Aggiungi la location del checkout se disponibile
        if (checkoutLocation) {
          updateData.checkout_location = {
            latitude: checkoutLocation.latitude,
            longitude: checkoutLocation.longitude,
            address: checkoutLocation.address,
            accuracy: checkoutLocation.accuracy,
            timestamp: checkoutLocation.timestamp.toISOString()
          };
        }

        console.log('üìù Dati da aggiornare:', updateData);
        console.log('üîç Condizione WHERE: id =', currentSession.id);

        // Prima verifica che il record esista
        const { data: existingRecord, error: checkError } = await supabase
          .from('warehouse_checkins')
          .select('*')
          .eq('id', currentSession.id)
          .maybeSingle();

        console.log('üîç Verifica record esistente:', existingRecord);

        if (checkError) {
          console.error('‚ùå ERRORE nella verifica del record:', checkError);
        }

        if (!existingRecord) {
          console.error('‚ùå Record NON TROVATO in warehouse_checkins con id:', currentSession.id);
          console.error('‚ùå Sessione corrente completa:', JSON.stringify(currentSession, null, 2));
          return false;
        }

        console.log('‚úÖ Record esistente trovato, procedo con update');

        const { data, error } = await supabase
          .from('warehouse_checkins')
          .update(updateData)
          .eq('id', currentSession.id)
          .select()
          .maybeSingle();

        if (error) {
          console.error('‚ùå ERRORE UPDATE WAREHOUSE CHECK-OUT:', error);
          console.error('‚ùå Dettagli errore:', JSON.stringify(error, null, 2));
          console.error('‚ùå Codice errore:', error.code);
          console.error('‚ùå Messaggio errore:', error.message);
          return false;
        }

        if (!data) {
          console.error('‚ùå Nessun dato restituito dall\'update (possibile record non trovato dopo update)');
          return false;
        }

        console.log('‚úÖ Check-out magazzino salvato nel DB:', data);
        console.log('‚úÖ Verifica campi aggiornati:');
        console.log('   - check_out_time:', data.check_out_time);
        console.log('   - status:', data.status);
      } else {
        console.log(`üíæ Aggiornamento timesheet_entries id=${currentSession.id}`);

        const { data, error } = await supabase
          .from('timesheet_entries')
          .update({
            end_time: checkOutTime,
            status: 'submitted'
          })
          .eq('id', currentSession.id)
          .select()
          .single();

        if (error) {
          console.error('‚ùå ERRORE UPDATE TIMESHEET CHECK-OUT:', error);
          console.error('‚ùå Dettagli errore:', JSON.stringify(error, null, 2));
          return false;
        }

        console.log('‚úÖ Check-out evento salvato nel DB:', data);
      }

      console.log('‚úÖ Check-out completato con successo nel database');
      return true;

    } catch (error) {
      console.error('‚ùå Errore nel check-out manuale:', error);
      return false;
    }
  };

  return {
    currentSession,
    activeSessions,
    elapsedTime,
    elapsedTimes,
    isLoading,
    startSession,
    endSession,
    manualCheckOut,
    loadActiveSession,
  };
};